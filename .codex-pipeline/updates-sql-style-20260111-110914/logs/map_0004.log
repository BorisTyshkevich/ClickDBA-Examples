OpenAI Codex v0.80.0 (research preview)
--------
workdir: /Users/bvt/work/ClickDBA/q1-fhir
model: gpt-5.2
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: medium
reasoning summaries: auto
session id: 019bac88-a0af-7261-9dae-b10b2d2d6dbe
--------
user
You are reading a single chunk from a larger article.
Do NOT run any commands or tools.
Do NOT add filler. Be information-dense and practical.
If something is uncertain, say so briefly.

CHUNK 4/4:
-----
async : Runs all updates with no coordination.

update_sequential_consistency (off by default): Ensures each update sees the latest visible state, at some performance cost.

But for most workloads, the default is fast, safe, and does the right thing.

All of this coordination happens behind the scenes, so that from the outside, updates just feel like SQL. It just works.

As we reach the end of this post, let’s step back and look at the bigger picture.

From engine-specific tricks to familiar SQL #

Patch parts bring efficient SQL-style UPDATEs to ClickHouse, not by breaking the rules of columnar storage, but by embracing them.

We leaned into what makes ClickHouse fast: 
Inserts are fast. Merges are continuous. Parts are immutable and sorted.

And because inserts are so fast , we turned updates into inserts. 
ClickHouse inserts compact patch parts behind the scenes and applies them efficiently during merges.

Merges are already happening, so we made them do more. Without really doing more. 
Since the engine is already merging data parts in the background, it now applies updates with minimal overhead.

Patch parts slide in instantly with minimal impact on query performance. 
Updates show up right away, with not-yet-merged patches applied in a way that preserves parallelism.

This is the core mechanism that now powers lightweight updates in ClickHouse.

They build on the same principles as engines like ReplacingMergeTree, but in a fully general way, encapsulated behind flexible, standard SQL syntax:

1 UPDATE orders 2 SET discount = 0.2 3 WHERE quantity >= 40 ;

The result: Updates show up instantly. Queries stay fast. Nothing blocks. It’s UPDATE, the ClickHouse way. All in familiar SQL.

In Part 3 , we’ll put it to the test. 
We benchmark every update method, mutations, on-the-fly mutations, and lightweight patch parts updates, and show just how fast standard SQL UPDATEs in ClickHouse can get. 
Spoiler: it’s not just faster. It’s up to 1,000× faster. Sometimes even more.
-----

Task: Extract ONLY content relevant to this goal:
GOAL: Write an operator-facing HOWTO for ClickHouse SQL-style UPDATE/DELETE (patch parts / lightweight updates). Include: prerequisites/compatibility, enabling flags/settings, safe rollout checklist, 2–4 minimal example SQL commands, verification steps/queries, gotchas/limits. Exclude design rationale, benchmarks, images, proofs, marketing. Use concise bullets and headings.

Output format (markdown; keep it concise):
- Prefer actionable “how-to” material over explanations of design decisions.
- Include concrete settings/flags and their values when mentioned.
- Include short example SQL snippets (fenced code blocks) if the chunk contains enough detail.
- Include 2–6 “gotchas/limits/compatibility” bullets if mentioned.
- Avoid: deep internal design rationale, pictures, proofs, marketing fluff.

Output structure:
1) `## Practical notes` (bullets)
2) `## Settings & knobs` (bullets, `name = value` when possible)
3) `## Examples` (0–2 fenced SQL blocks + 1–3 bullets)
4) `## Gotchas` (bullets)
5) `## Verification` (0–1 fenced SQL block + 2–6 bullets)

mcp: gh-mcp starting
mcp: ai-demo starting
mcp: gh-demo starting
mcp: gh-demo ready
mcp: ai-demo ready
mcp: gh-mcp ready
mcp startup: ready: gh-demo, ai-demo, gh-mcp
codex
## Practical notes
- `async` mode: runs all updates with no coordination.
- Default behavior is described as “fast, safe,” and generally correct for most workloads.
- Coordination is automatic/transparent to the operator; updates “feel like SQL”.

## Settings & knobs
- `update_sequential_consistency = 0` (off by default)
- `update_sequential_consistency = 1` ensures each update sees the latest visible state (performance cost).
- `async` (mode): no coordination (exact setting name/value not specified in this chunk).

## Examples
```sql
UPDATE orders
SET discount = 0.2
WHERE quantity >= 40;
```
- Standard SQL `UPDATE ... SET ... WHERE ...` is supported (example shown).

## Gotchas
- `update_sequential_consistency` has a performance cost when enabled.
- `async` updates have “no coordination” (may matter for ordering/visibility expectations; details not specified here).

## Verification
- Verify via normal query reads after the `UPDATE` (specific verification queries not provided in this chunk).
- If using `update_sequential_consistency = 1`, expect updates to reflect the latest visible state per update.
- If using `async`, don’t assume coordinated/serialized update visibility across concurrent updates (details not specified here).
tokens used
9,124
## Practical notes
- `async` mode: runs all updates with no coordination.
- Default behavior is described as “fast, safe,” and generally correct for most workloads.
- Coordination is automatic/transparent to the operator; updates “feel like SQL”.

## Settings & knobs
- `update_sequential_consistency = 0` (off by default)
- `update_sequential_consistency = 1` ensures each update sees the latest visible state (performance cost).
- `async` (mode): no coordination (exact setting name/value not specified in this chunk).

## Examples
```sql
UPDATE orders
SET discount = 0.2
WHERE quantity >= 40;
```
- Standard SQL `UPDATE ... SET ... WHERE ...` is supported (example shown).

## Gotchas
- `update_sequential_consistency` has a performance cost when enabled.
- `async` updates have “no coordination” (may matter for ordering/visibility expectations; details not specified here).

## Verification
- Verify via normal query reads after the `UPDATE` (specific verification queries not provided in this chunk).
- If using `update_sequential_consistency = 1`, expect updates to reflect the latest visible state per update.
- If using `async`, don’t assume coordinated/serialized update visibility across concurrent updates (details not specified here).
