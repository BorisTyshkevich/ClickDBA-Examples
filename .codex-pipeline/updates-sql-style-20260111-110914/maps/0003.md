## Practical notes
- UPDATE/DELETE create **patch parts** containing row identifiers + new column values.
- Updates are **non-blocking**: each UPDATE runs against a **snapshot of parts** present when the UPDATE starts (does not wait for merges).
- If target parts still exist, patching can be applied efficiently during merges; if parts were merged away first, ClickHouse can still apply the patch using preserved block-based identifiers.
- DELETE in `lightweight_update` mode becomes “set `_row_exists = 0` via patch part”; rows disappear after a background merge, and queries ignore `_row_exists = 0` in the meantime (“patch-on-read”).
- Optional: you can fully materialize accumulated changes via `ALTER TABLE … APPLY PATCHES`.
- Patch parts are regular parts: they count toward `TOO_MANY_PARTS` (per partition) and are cleaned up after materialization/merges.

## Settings & knobs
- `lightweight_delete_mode = lightweight_update`
- `update_parallel_mode = auto` (default; serializes dependent updates, runs others in parallel)
- `update_parallel_mode = sync` (run all updates one at a time)

## Examples
```sql
-- DELETE as patch part (lightweight_update mode): marks rows as deleted until merged away
DELETE FROM t WHERE /* predicate */ ;
```

```sql
-- Optional: force materialization of accumulated patch parts into data parts
ALTER TABLE t APPLY PATCHES;
```
- UPDATE patch parts store “updated columns = new values” plus system metadata to target the original rows.

## Gotchas
- If affected source parts are merged before the patch is applied, ClickHouse may fall back to a **hash join** on `(_block_number, _block_offset)`, which is **slower** and **more memory-hungry** (patch must fit in memory).
- Patch parts **increase part counts** and can hit `TOO_MANY_PARTS` (per partition).
- Multiple UPDATEs affecting different column sets create **separate patch partitions** (partitioned by the set of updated columns), which changes how part counts accrue.
- Concurrent updates: if two updates touch the same columns, ClickHouse enforces correct ordering automatically; `update_parallel_mode` can change concurrency.

## Verification
```sql
-- If you need to ensure patch parts are fully materialized
ALTER TABLE t APPLY PATCHES;
```
- After a lightweight-update DELETE, queries should stop returning deleted rows immediately (they’re ignored when `_row_exists = 0`), even before the next merge.
- Confirm background merges have run if you expect physical row removal (row disappears after merge).
- If you suspect “slow path” patching, check memory pressure during updates that occur while merges remove the original parts (chunk notes this can happen but “rarely”).