async : Runs all updates with no coordination.

update_sequential_consistency (off by default): Ensures each update sees the latest visible state, at some performance cost.

But for most workloads, the default is fast, safe, and does the right thing.

All of this coordination happens behind the scenes, so that from the outside, updates just feel like SQL. It just works.

As we reach the end of this post, let’s step back and look at the bigger picture.

From engine-specific tricks to familiar SQL #

Patch parts bring efficient SQL-style UPDATEs to ClickHouse, not by breaking the rules of columnar storage, but by embracing them.

We leaned into what makes ClickHouse fast: 
Inserts are fast. Merges are continuous. Parts are immutable and sorted.

And because inserts are so fast , we turned updates into inserts. 
ClickHouse inserts compact patch parts behind the scenes and applies them efficiently during merges.

Merges are already happening, so we made them do more. Without really doing more. 
Since the engine is already merging data parts in the background, it now applies updates with minimal overhead.

Patch parts slide in instantly with minimal impact on query performance. 
Updates show up right away, with not-yet-merged patches applied in a way that preserves parallelism.

This is the core mechanism that now powers lightweight updates in ClickHouse.

They build on the same principles as engines like ReplacingMergeTree, but in a fully general way, encapsulated behind flexible, standard SQL syntax:

1 UPDATE orders 2 SET discount = 0.2 3 WHERE quantity >= 40 ;

The result: Updates show up instantly. Queries stay fast. Nothing blocks. It’s UPDATE, the ClickHouse way. All in familiar SQL.

In Part 3 , we’ll put it to the test. 
We benchmark every update method, mutations, on-the-fly mutations, and lightweight patch parts updates, and show just how fast standard SQL UPDATEs in ClickHouse can get. 
Spoiler: it’s not just faster. It’s up to 1,000× faster. Sometimes even more.